 <!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Dragon-like Viral Reptile Skeleton (Canvas)</title>
<style>
  :root{
    --bg:#0b0720;
    --panel: rgba(255,255,255,0.06);
    --accent: white;
  }
  html,body{ height:100%; margin:0; background: radial-gradient(1200px 600px at 10% 10%, #12102a 0%, var(--bg) 40%), var(--bg); color:var(--accent); font-family: Inter, system-ui, sans-serif;}
  .wrap{ display:flex; flex-direction:column; gap:.8rem; align-items:center; padding:1rem; box-sizing:border-box; min-height:100vh;}
  canvas{ display:block; width:100%; max-width:1000px; height:520px; border-radius:12px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.08)); box-shadow: 0 20px 60px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);}
  .controls{ display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; justify-content:center; margin-top:.2rem;}
  .btn, .label, input[type=range]{
    background:var(--panel);
    color:var(--accent);
    border:1px solid rgba(255,255,255,0.06);
    padding:.45rem .6rem;
    border-radius:.6rem;
    font-size:.92rem;
    cursor:pointer;
    outline:none;
  }
  .small{ font-size:.86rem; padding:.35rem .5rem; }
  .label{ display:flex; gap:.5rem; align-items:center;}
  .hint{ opacity:.8; font-size:.85rem; margin-top:.2rem; text-align:center; max-width:1000px; }
  @media (max-width:640px){
    canvas{ height:420px; }
  }
</style>
</head>
<body>
  <div class="wrap">
    <canvas id="c"></canvas>

    <div class="controls" role="group" aria-label="Animation controls">
      <button id="toggleFollow" class="btn small">Toggle Cursor Follow: OFF</button>
      <button id="pauseBtn" class="btn small">Pause</button>
      <label class="label">
        Speed
        <input id="speedRange" type="range" min="0.3" max="2.5" step="0.05" value="1.0">
      </label>
      <label class="label">
        Scale
        <input id="scaleRange" type="range" min="0.6" max="1.6" step="0.05" value="1.0">
      </label>
      <button id="resetBtn" class="btn small">Reset Pose</button>
    </div>

    <div class="hint">Dragon-style viral skeleton: auto-walk + physics spine + legs + cursor follow. Click canvas to toggle faster burst.</div>
  </div>

<script>
/*
  Dragon-like viral reptile skeleton (Canvas)
  - Spine built from many segments (bones)
  - Inverse-kinematics-like pass (follow target head position)
  - Sine & easing for organic slither
  - Legs attached to specific spine segments (drawn as small bone lines with rotating joints)
  - Head with horns and an animated jaw
  - Cursor-follow toggle + auto-walk path
  - Controls for speed/scale/pause/reset
*/

/* ---------- Configurable parameters ---------- */
const CONFIG = {
  segmentCount: 48,        // number of spine segments (more -> smoother long body)
  boneLength: 12,          // base length of each segment (scaled)
  legInterval: 4,          // every n-th segment has a leg pair
  legLength: 16,           // length of leg bone
  legSwing: 0.9,           // how wide leg swings (radians)
  tailFlex: 0.9,           // tail flexibility multiplier
  headSizeRatio: 1.6,      // head relative to bone length
  horns: true,
  jawOpenAmount: 12,       // px jaw open amplitude
  lineWidth: 2.2,
  color: '#ffffff',
  autoWalkSpeed: 0.9,      // base auto walk speed (multiplied by UI speed)
  waveMagnitude: 0.35      // body wave amplitude (multiples of boneLength)
};

/* ---------- Setup canvas & responsive sizing ---------- */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: true });

let DPR = Math.max(1, window.devicePixelRatio || 1);

function resizeCanvas() {
  DPR = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = Math.floor(canvas.clientWidth * DPR);
  canvas.height = Math.floor(canvas.clientHeight * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* ---------- Spine data structure ---------- */
class Segment {
  constructor(x, y, length){
    this.x = x; this.y = y;
    this.angle = 0;
    this.length = length;
    this.targetX = x; this.targetY = y;
    this.prevX = x; this.prevY = y;
  }
}

let segments = [];
let scale = 1.0;
function initSegments(){
  segments = [];
  const L = CONFIG.boneLength * scale;
  // Place in a curved rest pose from left to right
  const startX = canvas.width / (2*DPR) - 220*scale;
  const startY = canvas.height / (2*DPR);
  for(let i=0;i<CONFIG.segmentCount;i++){
    const x = startX + i * L * 0.92; // slight overlap so it's curvy
    const y = startY + Math.sin(i*0.26) * 12 * scale;
    segments.push(new Segment(x,y,L));
  }
}
initSegments();

/* ---------- Animation state ---------- */
let time = 0;
let paused = false;
let followCursor = false;
let speedMultiplier = 1.0;
let burst = 0; // temporary speed burst when clicked
let mouse = { x: null, y: null };

/* ---------- Controls UI ---------- */
const toggleFollowBtn = document.getElementById('toggleFollow');
const pauseBtn = document.getElementById('pauseBtn');
const speedRange = document.getElementById('speedRange');
const scaleRange = document.getElementById('scaleRange');
const resetBtn = document.getElementById('resetBtn');

toggleFollowBtn.addEventListener('click', () => {
  followCursor = !followCursor;
  toggleFollowBtn.textContent = `Toggle Cursor Follow: ${followCursor ? 'ON' : 'OFF'}`;
});
pauseBtn.addEventListener('click', () => {
  paused = !paused;
  pauseBtn.textContent = paused ? 'Resume' : 'Pause';
});
speedRange.addEventListener('input', () => speedMultiplier = parseFloat(speedRange.value));
scaleRange.addEventListener('input', () => {
  scale = parseFloat(scaleRange.value);
  initSegments();
});
resetBtn.addEventListener('click', initSegments);

/* ---------- Mouse events ---------- */
canvas.addEventListener('mousemove', (e) => {
  const r = canvas.getBoundingClientRect();
  mouse.x = (e.clientX - r.left);
  mouse.y = (e.clientY - r.top);
  // normalize for DPR already handled in drawing scale
});
canvas.addEventListener('mouseleave', () => { mouse.x = null; mouse.y = null; });
canvas.addEventListener('click', () => { burst = 0.9; }); // quick speed burst

/* ---------- Utility helpers ---------- */
function lerp(a,b,t){ return a + (b-a)*t; }
function dist(ax,ay,bx,by){ return Math.hypot(bx-ax, by-ay); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

/* ---------- Main physics + drawing ---------- */
function update(dt){
  if(paused) return;

  time += dt * speedMultiplier;

  // compute head target position:
  // If followCursor && mouse exists -> lerp head target to mouse
  // otherwise follow auto-walk path (sine wave along X)
  const head = segments[0];
  const baseSpeed = CONFIG.autoWalkSpeed * speedMultiplier;
  const travel = time * 60 * baseSpeed; // horizontal travel amount
  const centerY = canvas.height / (2*DPR);
  const pathX = (canvas.width/(2*DPR)) + Math.sin(time*0.7) * 90*scale + Math.cos(time*0.3)*60*scale - 320*scale + travel% (canvas.width/(2*DPR) + 600*scale);
  const pathY = centerY + Math.sin(time*1.4) * (20*scale) + Math.cos(time*0.6)*16*scale;
  const target = { x: pathX, y: pathY };

  if(followCursor && mouse.x !== null){
    // move head toward cursor more strongly
    head.targetX = lerp(head.x, mouse.x, 0.22);
    head.targetY = lerp(head.y, mouse.y, 0.22);
  } else {
    // auto-walk
    head.targetX = lerp(head.x, target.x, 0.12 + 0.02 * Math.sin(time*1.3));
    head.targetY = lerp(head.y, target.y, 0.08 + 0.02 * Math.cos(time*1.9));
  }

  // apply burst decay
  if(burst > 0){
    burst = Math.max(0, burst - dt*0.9);
  }

  // IK-ish pass: enforce distances and create a wave along the body
  let wavePhase = time * 2.2;
  for(let i=0;i<segments.length;i++){
    const s = segments[i];
    if(i===0){
      // head moves toward its target using a springy lerp
      s.x = lerp(s.x, s.targetX, 0.36 + 0.25 * burst);
      s.y = lerp(s.y, s.targetY, 0.36 + 0.25 * burst);
    } else {
      // follow previous segment ensuring fixed length
      const prev = segments[i-1];
      // desired angle: from this segment to prev (so segment sits behind prev)
      let dx = s.x - prev.x;
      let dy = s.y - prev.y;
      let angle = Math.atan2(dy, dx);
      // compute target position by placing this segment at prev - length along angle
      const targetX = prev.x + Math.cos(angle) * prev.length;
      const targetY = prev.y + Math.sin(angle) * prev.length;
      // smooth move toward that spot
      s.x = lerp(s.x, targetX, 0.45 + 0.05 * Math.sin(time + i*0.12));
      s.y = lerp(s.y, targetY, 0.45 + 0.05 * Math.cos(time + i*0.08));
    }

    // compute angle between current and previous for drawing bones
    if(i>0){
      const prev = segments[i-1];
      s.angle = Math.atan2(prev.y - s.y, prev.x - s.x);
    } else {
      // head angle: look to next for direction
      if(segments.length>1){
        const next = segments[1];
        s.angle = Math.atan2(next.y - s.y, next.x - s.x) + Math.PI; // face forward
      }
    }

    // add a traveling sine wave offset perpendicular to the bone to make it slither
    const wave = Math.sin(wavePhase - i * 0.28) * CONFIG.waveMagnitude * s.length;
    const perpAngle = s.angle - Math.PI / 2;
    s.x += Math.cos(perpAngle) * wave * (0.15 + 0.85 * (i / segments.length));
    s.y += Math.sin(perpAngle) * wave * (0.15 + 0.85 * (i / segments.length));
    wavePhase += 0.02;
  }

  // tail elasticity pass (slight smoothing from tail to head)
  for(let j=segments.length-2;j>=0;j--){
    const s = segments[j];
    const next = segments[j+1];
    const d = dist(s.x,s.y,next.x,next.y);
    const desired = s.length;
    const diff = (d - desired) * CONFIG.tailFlex * 0.2;
    if(d !== 0){
      const nx = (next.x - s.x) / d;
      const ny = (next.y - s.y) / d;
      // nudge next toward desired distance
      next.x -= nx * diff;
      next.y -= ny * diff;
    }
  }
}

/* ---------- Drawing routine ---------- */
function draw(){
  // clear
  ctx.clearRect(0,0, canvas.width/DPR, canvas.height/DPR);

  // background vignette / glow (subtle)
  const g = ctx.createLinearGradient(0,0,0,canvas.height/DPR);
  g.addColorStop(0, 'rgba(255,255,255,0.02)');
  g.addColorStop(1, 'rgba(0,0,0,0.06)');
  ctx.fillStyle = g;
  ctx.fillRect(0,0, canvas.width/DPR, canvas.height/DPR);

  // Setup stroke style for bone lines
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';
  ctx.strokeStyle = CONFIG.color;
  ctx.fillStyle = CONFIG.color;

  // draw bones as short segments between segment centers
  for(let i=segments.length-1;i>0;i--){
    const a = segments[i], b = segments[i-1];
    const midX = (a.x + b.x)/2;
    const midY = (a.y + b.y)/2;
    const len = dist(a.x,a.y,b.x,b.y);
    const angle = Math.atan2(b.y - a.y, b.x - a.x);

    // bone width taper: thicker near head, thinner at tail
    const t = 1 - (i / segments.length);
    const w = CONFIG.lineWidth * (0.75 + 1.8 * t) * scale;
    ctx.lineWidth = w;

    // draw bone (slightly rounded rectangle via thick line)
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.stroke();
  }

  // draw small "ribs" or cross bones for skeleton look
  ctx.lineWidth = 1.0 * scale;
  for(let i=2;i<segments.length-3;i+=1){
    const s = segments[i];
    const angle = s.angle;
    // rib length reduces toward tail
    const ribLen = CONFIG.boneLength * 0.9 * (1 - i/segments.length) * scale;
    // alternate sides
    const side = (i % 2 === 0) ? 1 : -1;
    const px = s.x + Math.cos(angle + Math.PI/2) * side * ribLen * 0.55;
    const py = s.y + Math.sin(angle + Math.PI/2) * side * ribLen * 0.55;
    ctx.beginPath();
    ctx.moveTo(s.x, s.y);
    ctx.lineTo(px, py);
    ctx.stroke();
  }

  // draw legs at specified intervals
  for(let i=0;i<segments.length;i++){
    if(i % CONFIG.legInterval !== 0) continue;
    if(i < 6) continue; // avoid legs too close to head
    const s = segments[i];
    const side = (i % (CONFIG.legInterval*2) === 0) ? 1 : -1;
    const baseAngle = s.angle - Math.PI/2 * side; // direction outward
    // leg swing animation
    const swing = Math.sin(time*4 + i*0.6) * CONFIG.legSwing * (0.9 - i/segments.length);
    const thighAngle = baseAngle + swing;
    const shinAngle = thighAngle + Math.sign(Math.sin(time*4 + i*0.3)) * 0.6 * (0.8 - i/segments.length);
    const thighLen = CONFIG.legLength * scale * (1 - i/segments.length*0.1);
    const shinLen = (CONFIG.legLength * 0.65) * scale * (1 - i/segments.length*0.08);

    // hip -> knee
    const hipX = s.x + Math.cos(thighAngle) * 4 * scale;
    const hipY = s.y + Math.sin(thighAngle) * 4 * scale;
    const kneeX = hipX + Math.cos(thighAngle) * thighLen;
    const kneeY = hipY + Math.sin(thighAngle) * thighLen;
    const footX = kneeX + Math.cos(shinAngle) * shinLen;
    const footY = kneeY + Math.sin(shinAngle) * shinLen;

    // draw thigh (thin bone)
    ctx.lineWidth = 1.6 * scale;
    ctx.beginPath();
    ctx.moveTo(hipX, hipY);
    ctx.lineTo(kneeX, kneeY);
    ctx.stroke();

    // draw shin
    ctx.lineWidth = 1.3 * scale;
    ctx.beginPath();
    ctx.moveTo(kneeX, kneeY);
    ctx.lineTo(footX, footY);
    ctx.stroke();

    // little foot/claw
    ctx.beginPath();
    ctx.arc(footX, footY, 1.6 * scale, 0, Math.PI*2);
    ctx.fill();

    // small connecting bone to body
    ctx.lineWidth = 0.9 * scale;
    ctx.beginPath();
    ctx.moveTo(s.x, s.y);
    ctx.lineTo(hipX, hipY);
    ctx.stroke();
  }

  // draw head with horns and jaw
  drawHead();
}

/* ---------- Head drawing ---------- */
function drawHead(){
  const head = segments[0];
  const next = segments[1];
  const angle = Math.atan2(next.y - head.y, next.x - head.x) + Math.PI; // facing forward
  // position forward from head center a bit
  const headRadius = CONFIG.boneLength * CONFIG.headSizeRatio * scale;
  const hx = head.x + Math.cos(angle) * 6 * scale;
  const hy = head.y + Math.sin(angle) * 6 * scale;

  // jaw animation based on time & cursor proximity
  let jawOpen = (Math.sin(time * 3.2) + 1) / 2; // 0..1
  // if cursor near head, open more
  if(mouse.x !== null){
    const md = dist(mouse.x, mouse.y, head.x, head.y);
    jawOpen = Math.max(jawOpen, clamp(1 - md / 180, 0, 1));
  }
  jawOpen *= 0.8;
  // draw head main shape (as skeleton: two arcs)
  ctx.save();
  ctx.translate(hx, hy);
  ctx.rotate(angle);

  // skull outline: long, pointed snout for dragon look
  ctx.lineWidth = 2.6 * scale;
  ctx.beginPath();
  ctx.moveTo(-headRadius*0.9, -headRadius*0.3);
  ctx.quadraticCurveTo(headRadius*0.9, 0, -headRadius*0.9, headRadius*0.3);
  ctx.stroke();

  // snout bones (little lines)
  ctx.lineWidth = 1.2*scale;
  ctx.beginPath();
  ctx.moveTo(headRadius*0.2, -headRadius*0.05);
  ctx.lineTo(headRadius*0.6, -headRadius*0.05);
  ctx.moveTo(headRadius*0.2, headRadius*0.05);
  ctx.lineTo(headRadius*0.6, headRadius*0.05);
  ctx.stroke();

  // horns (two small spikes)
  if(CONFIG.horns){
    ctx.lineWidth = 2*scale;
    ctx.beginPath();
    ctx.moveTo(-headRadius*0.5, -headRadius*0.3);
    ctx.lineTo(-headRadius*0.9, -headRadius*0.9);
    ctx.moveTo(-headRadius*0.1, -headRadius*0.4);
    ctx.lineTo(-headRadius*0.2, -headRadius*1.0);
    ctx.stroke();
  }

  // jaw (lower bone) - swings open downwards
  const jawOffset = jawOpen * CONFIG.jawOpenAmount * scale;
  ctx.lineWidth = 2*scale;
  ctx.beginPath();
  ctx.moveTo(-headRadius*0.85, headRadius*0.32);
  ctx.lineTo(headRadius*0.55, headRadius*0.8 + jawOffset);
  ctx.stroke();

  // eye socket (hollow dot)
  ctx.beginPath();
  ctx.arc(-headRadius*0.25, -headRadius*0.05, Math.max(1.6*scale, headRadius*0.12), 0, Math.PI*2);
  ctx.stroke();

  ctx.restore();
}

/* ---------- Animation loop ---------- */
let last = performance.now();
function tick(now){
  const dt = Math.min(0.033, (now - last) / 1000); // cap dt ~33ms
  last = now;

  // update state
  if(!paused) update(dt);

  // draw
  draw();

  // slight speed modulation and burst integration
  const effective = 1 + burst * 1.2;
  // animate next frame scaled by burst factor (we simply accelerate internal clock via speedMultiplier already)
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* ---------- Initialize UI values ---------- */
speedRange.value = 1.0;
scaleRange.value = 1.0;

/* ---------- Helpful: Adjust global variables from UI (observed live) ---------- */
(function liveUpdate(){
  const apply = () => {
    CONFIG.boneLength = 12 * parseFloat(scaleRange.value);
    // Re-init segments when scale changes a lot
  };
  scaleRange.addEventListener('input', () => {
    apply();
    initSegments();
  });
})();

/* ---------- Small helper: keep canvas crisp on first load ---------- */
window.addEventListener('load', () => {
  resizeCanvas();
  initSegments();
});
</script>
</body>
</html>
